<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Night Racing ‚Äì Crash‚ÜíIdle Night, Random Spawns, Fresh Collisions v9.1</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%;background:#000}
    #root{height:100dvh;width:100vw;overflow:hidden}
    .full-screen-3d-example{opacity:0;transition:opacity 1s ease-out}
    .full-screen-3d-example.-loaded{opacity:1}

    /* Overlay g√ºvenlik */
    .overlay.hidden{display:none!important;}

    /* === HUD: Puan & S√ºre √ºst-ORTA === */
    .hud{
      position:fixed;
      top: max(14px, env(safe-area-inset-top));
      left:50%;
      right:auto;
      transform:translateX(-50%);
      display:flex;
      gap:10px;
      z-index:9;
      font-family:ui-monospace,Menlo,Consolas,monospace;
      color:#fff;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    .hud .pill{
      background:rgba(0,0,0,.35);padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);
      text-shadow:0 0 8px rgba(76,201,240,.35)
    }

    :root { --lower-ui-top: 72%;   --fab-lift: 36px; --safe-bottom: env(safe-area-inset-bottom); --fab-gap: 52px; } /* 68‚Äì76% arasƒ± deneyebilirsin */

    /* TOASTS ‚Üí alt orta ve SADECE METƒ∞N */
    .toasts{
      position:fixed;
      top: var(--lower-ui-top);
      left:50%;
      transform:translate(-50%,-50%);
      display:flex;flex-direction:column;align-items:center;gap:8px;
      z-index:10; pointer-events:none;
    }
    .toast{
      background: transparent;
      border: 0;
      padding: 0;
      color:#fff;
      font-family: ui-monospace,Menlo,Consolas,monospace;
      font-size: 18px;
      opacity:0; transform:translateY(10px) scale(.98);
      transition:opacity .25s ease, transform .25s ease;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
      will-change: transform, opacity; /* mobil */
    }
    .toast.show{ opacity:1; transform:translateY(0) scale(1) }

    /* OVERLAY ‚Üí alt-ortada buton */
    .overlay{ position:fixed; inset:0; display:block; background: none; z-index:12; pointer-events:none;     /* ‚Üê kritik */}
    .overlay .panel{
      pointer-events:auto;     /* Yalnƒ±zca panel tƒ±klanabilir kalsƒ±n */
    }
    .panel{
      position:absolute;
      top: var(--lower-ui-top);
      left:50%;
      transform:translate(-50%,-50%);
      background: none; border: 0; box-shadow: none; padding: 0;
      color:#fff; text-align:center;
      font-family: ui-monospace,Menlo,Consolas,monospace;
      min-width: unset;
    }
    .panel h1{ font-size:20px; margin-bottom:6px; text-shadow:0 2px 10px rgba(0,0,0,.6) }
    .panel p { opacity:.9;  margin-bottom:10px }
    .panel button{
      all: unset; cursor: pointer; display: inline-block; padding: 10px 18px; border-radius: 14px; color:#fff; font-weight:800;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
      background: linear-gradient(to bottom, rgba(255,255,255,.18), rgba(255,255,255,.06));
      border: 1px solid rgba(255,255,255,.28);
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25), inset 0 -8px 18px rgba(255,255,255,.08);
      backdrop-filter: blur(12px) saturate(160%); -webkit-backdrop-filter: blur(12px) saturate(160%);
      transform: translateZ(0);
      transition: transform .12s ease, box-shadow .12s ease, filter .12s ease;
    }
    .panel button:hover{
      transform: translateY(-1px) scale(1.02);
      box-shadow: 0 12px 36px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.3), inset 0 -8px 18px rgba(255,255,255,.1);
    }
    .panel button:active{ transform: translateY(1px) scale(.99); }
    .overlay.hidden { display: none !important; }

    /* Saƒü-alt ses paneli (aero glass) */
    .audio-panel{
      position: fixed;
      left: 50%;
      right: auto;          /* eskiyi iptal */
      bottom: calc(max(14px, var(--safe-bottom)) + var(--fab-lift) + var(--fab-gap)); /* FAB y√ºksekliƒüi + bo≈üluk */
      transform: translateX(-50%);
      display:flex; flex-direction:column; gap:10px;
      padding:10px 12px; border-radius:16px;
      background: linear-gradient(to bottom, rgba(255,255,255,.18), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.28);
      box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25), inset 0 -8px 18px rgba(255,255,255,.08);
      backdrop-filter: blur(12px) saturate(160%); -webkit-backdrop-filter: blur(12px) saturate(160%);
      color:#fff; font-family: ui-monospace,Menlo,Consolas,monospace;
    }
    .audio-panel .row{ display:flex; align-items:center; gap:8px; min-width:220px; }
    .audio-panel label{ width:52px; opacity:.9; }
    .audio-panel .vol{ flex:1; accent-color:#4cc9f0; }
    .mute-btn{ all:unset; cursor:pointer; width:32px; height:32px; display:grid; place-items:center; border-radius:50%;
      background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); }
    .mute-btn .icon-on{display:block}
    .mute-btn .icon-off{display:none}
    .mute-btn[data-muted="true"] .icon-on{display:none}
    .mute-btn[data-muted="true"] .icon-off{display:block}

    .toast .points{ color: #0cf400; font-weight: 700; }
    .hidden{ display:none !important; }

    /* FAB: ? ve Ses Ayarlarƒ± ALT-ORTA */
    .fab-col{
      position: fixed;
      left: 50%;
      bottom: calc(max(14px, var(--safe-bottom)) + var(--fab-lift));
      transform: translateX(-50%);
      display: flex; gap: 10px;
      z-index: 13; pointer-events: auto;
    }
    .glass-btn{
      all:unset; cursor:pointer; width:38px; height:38px; display:grid; place-items:center; border-radius:999px; color:#fff;
      background: linear-gradient(to bottom, rgba(255,255,255,.18), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.28);
      box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25), inset 0 -8px 18px rgba(255,255,255,.08);
      backdrop-filter: blur(12px) saturate(160%); -webkit-backdrop-filter: blur(12px) saturate(160%);
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .glass-btn:hover{
      transform:translateY(-1px) scale(1.02);
      box-shadow:0 12px 36px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.30), inset 0 -8px 18px rgba(255,255,255,.10);
    }
    .glass-btn:active{ transform:translateY(1px) scale(.98); }
    .glass-btn svg{ width:22px; height:22px; display:block; }

    /* Yardƒ±m paneli */
    .glass-panel{
      position:fixed; top:68px; right:14px; z-index:14;
      width:min(420px, calc(100vw - 28px)); max-height:min(70vh, 520px); overflow:auto;
      padding:12px 14px; border-radius:16px; color:#fff; font-family:ui-monospace,Menlo,Consolas,monospace;
      background:linear-gradient(to bottom, rgba(255,255,255,.18), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.28);
      box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25), inset 0 -8px 18px rgba(255,255,255,.08);
      backdrop-filter: blur(12px) saturate(160%); -webkit-backdrop-filter: blur(12px) saturate(160%);
    }
  </style>

  <!-- Libs (r146) -->
  <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/objects/Reflector.js"></script>
</head>
<body>

  <div id="root" class="full-screen-3d-example"></div>

  <!-- HUD -->
  <div class="hud">
    <div class="pill" id="hud-score">Puan: 0</div>
    <div class="pill" id="hud-time">S√ºre: 00:00.0</div>
  </div>

  <!-- Toasts (center) -->
  <div class="toasts" id="toasts"></div>

  <!-- Start/Crash Overlay -->
  <div class="overlay" id="overlay">
    <div class="panel">
      <h1 id="ovlTitle">Gece devriyesi üåô</h1>
      <p id="ovlDesc">Trafikli oyunu ba≈ülatmak i√ßin ‚ÄúBa≈üla‚Äùya bas.</p>
      <button id="playBtn">Ba≈üla</button>
    </div>
  </div>

  <!-- Ses Paneli (saƒü-alt) -->
  <div id="audioPanel" class="audio-panel hidden" role="group" aria-label="Ses denetimleri">
    <div class="row">
      <button id="bgmMuteBtn" class="mute-btn" type="button" aria-label="M√ºziƒüi kapat" data-muted="false" title="M√ºzik">
        <span class="icon-on">
          <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M17.5 8.43A4.985 4.985 0 0 1 19 12a4.984 4.984 0 0 1-1.43 3.5M14 6.135v11.73a1 1 0 0 1-1.64.768L8 15H6a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"/>
          </svg>
        </span>
        <span class="icon-off">
          <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M15.5 8.43A4.985 4.985 0 0 1 17 12c0 1.126-.5 2.5-1.5 3.5m2.864-9.864A8.972 8.972 0 0 1 21 12c0 2.023-.5 4.5-2.5 6M7.8 7.5l2.56-2.133a1 1 0 0 1 1.64.768V12m0 4.5v1.365a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1m1-4 14 14"/>
          </svg>
        </span>
      </button>
      <label for="bgmVol">M√ºzik</label>
      <input id="bgmVol" class="vol" type="range" min="0" max="100" value="60" />
    </div>

    <div class="row">
      <button id="engMuteBtn" class="mute-btn" type="button" aria-label="Motoru kapat" data-muted="false" title="Motor">
        <span class="icon-on">
          <!-- SES A√á -->
          <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M17.5 8.43A4.985 4.985 0 0 1 19 12a4.984 4.984 0 0 1-1.43 3.5M14 6.135v11.73a1 1 0 0 1-1.64.768L8 15H6a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"/>
          </svg>
        </span>
        <span class="icon-off">
          <!-- SES KAPAT -->
          <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M15.5 8.43A4.985 4.985 0 0 1 17 12c0 1.126-.5 2.5-1.5 3.5m2.864-9.864A8.972 8.972 0 0 1 21 12c0 2.023-.5 4.5-2.5 6M7.8 7.5l2.56-2.133a1 1 0 0 1 1.64.768V12m0 4.5v1.365a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1m1-4 14 14"/>
          </svg>
        </span>
      </button>
      <label for="engVol">Motor</label>
      <input id="engVol" class="vol" type="range" min="0" max="100" value="70" />
    </div>
  </div>

  <!-- ALT-ORTA: Yardƒ±m ve Ayarlar BUTONLARI (audioPanel dƒ±≈üƒ±na alƒ±ndƒ±) -->
  <div class="fab-col">
    <button id="helpBtn" class="glass-btn" title="Nasƒ±l oynanƒ±r?">
      <svg class="w-6 h-6" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
        <path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9.008-3.018a1.502 1.502 0 0 1 2.522 1.159v.024a1.44 1.44 0 0 1-1.493 1.418 1 1 0 0 0-1.037.999V14a1 1 0 1 0 2 0v-.539a3.44 3.44 0 0 0 2.529-3.256 3.502 3.502 0 0 0-7-.255 1 1 0 0 0 2 .076c.014-.398.187-.774.48-1.044Zm.982 7.026a1 1 0 1 0 0 2H12a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"/>
      </svg>
    </button>

    <button id="settingsBtn" class="glass-btn" title="Ses ayarlarƒ±">
      <svg class="w-6 h-6" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
        <path d="M13 6.037c0-1.724-1.978-2.665-3.28-1.562L5.638 7.933H4c-1.105 0-2 .91-2 2.034v4.066c0 1.123.895 2.034 2 2.034h1.638l4.082 3.458c1.302 1.104 3.28.162 3.28-1.562V6.037Z"/>
        <path fill-rule="evenodd" d="M14.786 7.658a.988.988 0 0 1 1.414-.014A6.135 6.135 0 0 1 18 12c0 1.662-.655 3.17-1.715 4.27a.989.989 0 0 1-1.414.014 1.029 1.029 0 0 1-.014-1.437A4.085 4.085 0 0 0 16 12a4.085 4.085 0 0 0-1.2-2.904 1.029 1.029 0 0 1-.014-1.438Z" clip-rule="evenodd"/>
        <path fill-rule="evenodd" d="M17.657 4.811a.988.988 0 0 1 1.414 0A10.224 10.224 0 0 1 22 12c0 2.807-1.12 5.35-2.929 7.189a.988.988 0 0 1-1.414 0 1.029 1.029 0 0 1 0-1.438A8.173 8.173 0 0 0 20 12a8.173 8.173 0 0 0-2.343-5.751 1.029 1.029 0 0 1 0-1.438Z"/>
      </svg>
    </button>
  </div>

  <!-- NASIL OYNANIR (√ºst-saƒü) -->
  <div id="helpPanel" class="glass-panel hidden" role="dialog" aria-label="Nasƒ±l oynanƒ±r">
    <h3>Nasƒ±l oynanƒ±r</h3>
    <ul>
      <li><span class="kbd">Mouse</span> ile direksiyon‚Ä¶</li>
      <li><span class="kbd">Space</span> veya <span class="kbd">Sol tƒ±k</span> basƒ±lƒ± tut: <strong>Boost</strong>.</li>
      <li>Odak kaybolduƒüunda boost otomatik kapanƒ±r.</li>
    </ul>

    <h3>Puanlama</h3>
    <ul>
      <li><strong>≈ûerit deƒüi≈ütirme</strong>: <span class="tag">+1</span></li>
      <li><strong>Makas</strong>: <span class="tag">+1</span></li>
      <li><strong>Boost a√ßƒ±kken yanƒ±ndan ge√ßi≈ü</strong>: <span class="tag">+3</span></li>
      <li><strong>Boost s√ºresi</strong>: her tam saniye <span class="tag">+1</span></li>
    </ul>

    <h3>Oyun akƒ±≈üƒ±</h3>
    <ul>
      <li><strong>Ba≈üla</strong>: Trafik a√ßƒ±lƒ±r, s√ºre/puan sƒ±fƒ±rlanƒ±r.</li>
      <li><strong>Kaza</strong>: Trafik kapanƒ±r; <em>Tekrar Oyna</em> ile yeni tur.</li>
    </ul>

    <h3>Zorluk & Trafik</h3>
    <ul>
      <li><strong>60. saniye</strong> sonrasƒ± spawn sƒ±klƒ±ƒüƒ± ve ara√ß sayƒ±sƒ± artar.</li>
      <li>≈ûerit hƒ±zlarƒ± farklƒ±dƒ±r (sol/orta/saƒü).</li>
      <li><strong>Duvar √∂nleme</strong>: aynƒ± z‚Äôde en fazla 2 ≈üerit dolu.</li>
    </ul>

    <h3>Ses</h3>
    <ul>
      <li><strong>Ses Ayarlarƒ±</strong> butonundan m√ºzik ve motoru ayrƒ± ayrƒ± kƒ±s/a√ß.</li>
    </ul>
  </div>

  <script>
  const { THREE } = window;

  function isMobile(){
    let check=false; (function(a){check=/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a.substr(0,4))})(navigator.userAgent||navigator.vendor||window.opera); return check;}
  const IS_MOBILE_DEVICE = isMobile();

  // ====== CONFIG ======
  const FLAGS = Object.freeze({ ENABLE_SHADOWS: !IS_MOBILE_DEVICE, ENABLE_BLOOM: !IS_MOBILE_DEVICE, ENABLE_NOISE: !IS_MOBILE_DEVICE });
  const COLOR_PALETTE = Object.freeze({ black:0x010101, white:0xeeeeee, color1:0xf72585, color2:0xb5179e, color3:0x7209b7, color4:0x560bad, color5:0x480ca8, color6:0x3a0ca3, color7:0x3f37c9, color8:0x4361ee, color9:0x4895ef, color10:0x4cc9f0 });
  const COLOR_PALETTE_GLSL = Object.freeze({ black:"vec4(0.04, 0.04, 0.04, 1.0)", white:"vec4(0.933, 0.933, 0.933, 1.0)", color1:"vec4(0.969, 0.145, 0.522, 1.0)", color2:"vec4(0.71, 0.09, 0.62, 1.0)", color3:"vec4(0.447, 0.035, 0.718, 1.0)", color4:"vec4(0.337, 0.043, 0.678, 1.0)", color5:"vec4(0.282, 0.047, 0.659, 1.0)", color6:"vec4(0.227, 0.047, 0.639, 1.0)", color7:"vec4(0.247, 0.216, 0.788, 1.0)", color8:"vec4(0.263, 0.38, 0.933, 1.0)", color9:"vec4(0.282, 0.584, 0.937, 1.0)", color10:"vec4(0.298, 0.788, 0.941, 1.0)" });

  // Motor d√∂ng√ºs√º (≈üimdilik tek loop kullanƒ±yoruz)
  const ENG_LOOP_START = 1.2;
  const ENG_LOOP_END   = 6.0;
  const ENG_FADE       = 0.25;

  // Smooth boost
  const BOOST_TARGET_MULT = 2.2;
  const BOOST_RAMP_UP_SEC = 2.4;
  const BOOST_RAMP_DOWN_SEC = 0.9;

  // √áarpƒ±≈üma kutularƒ±
  const HITBOX_PLAYER = { x: 0.70, y: 0.92, z: 0.84 };
  const HITBOX_NPC    = { x: 0.72, y: 0.92, z: 0.84 };
  const SIDE_SWIPE_X  = 0.38;

  function shrinkBox(box, scale){
    const size = new THREE.Vector3();
    const ctr  = new THREE.Vector3();
    box.getSize(size); box.getCenter(ctr);
    size.set(size.x*scale.x, size.y*scale.y, size.z*scale.z);
    box.min.set(ctr.x - size.x*0.5, ctr.y - size.y*0.5, ctr.z - size.z*0.5);
    box.max.set(ctr.x + size.x*0.5, ctr.y + size.y*0.5, ctr.z + size.z*0.5);
    return box;
  }

  // Sunrise config
  const SUNRISE_DURATION_SEC = 28;
  const NIGHT_AMBIENT = 0.02;
  const DAY_AMBIENT   = 0.10;
  const NIGHT_POINT   = 0.8;
  const DAY_POINT     = 5.0;

  // Lane switching config
  const CAR_BASE_X = 0.7;
  const CAR_LANE_AMPLITUDE = 3.6;
  const CAR_LERP = 0.08;
  const CAR_BANK_MAX = 0.20;
  const MOUSE_EXP = 1.25;

  // Camera tamer
  const CAMERA_MOUSE_X_FACTOR = 1.8;
  const CAMERA_PARALLAX = 0.60;
  const LOOK_FOLLOW_RATIO = 0.70;
  const LOOK_FOLLOW_STRENGTH = 0.08;

  // Traffic config
  const PARKED_MAX = 3;
  const PARKED_SPAWN_MIN_SEC = 3.2;
  const PARKED_SPAWN_MEAN = 3.8;
  const PARKED_BURST_CHANCE = 0.22;
  const PARKED_BURST_GAP = 6.0;

  const WALL_BAND_EARLY = 26;
  const WALL_BAND_MID   = 20;
  const WALL_BAND_LATE  = 16;
  const WALL_WAVE_PRUNE_SEC = 8.0;

  // Lane x
  const PARKED_LANE_X_LEFT   = CAR_BASE_X - (CAR_LANE_AMPLITUDE * 0.96) - 0.25;
  const PARKED_LANE_X_RIGHT  = CAR_BASE_X + (CAR_LANE_AMPLITUDE * 0.96) + 0.25;
  const PARKED_LANE_X_MIDDLE = CAR_BASE_X;

  // Speed knobs
  const CITY_BASE_SPEED = 1.0;
  const LANE_SPEED = Object.freeze({ LEFT:1.00, CENTER:1.15, RIGHT:0.90 });

  function clampLaneX(x, isLeft){
    const SHOULDER = 0.50, INSET = 0.40;
    if(isLeft){ const min = CAR_BASE_X - CAR_LANE_AMPLITUDE - SHOULDER; const max = CAR_BASE_X - CAR_LANE_AMPLITUDE + INSET; return Math.min(max, Math.max(min, x)); }
    else      { const min = CAR_BASE_X + CAR_LANE_AMPLITUDE - INSET;   const max = CAR_BASE_X + CAR_LANE_AMPLITUDE + SHOULDER; return Math.min(max, Math.max(min, x)); }
  }

  // ====== MATERIALS ======
  class DefaultMaterial extends THREE.MeshStandardMaterial{ constructor(){ super({ color:COLOR_PALETTE.white }); } }
  class CarMaterial extends THREE.MeshStandardMaterial{ constructor(){ super({ color:COLOR_PALETTE.black }); } }
  class LightMaterial extends THREE.MeshStandardMaterial{ constructor(){ super({ color:COLOR_PALETTE.color1, transparent:true, opacity:1 }); } }
  class WheelMaterial extends THREE.MeshStandardMaterial{ constructor(){ super({ color:COLOR_PALETTE.black }); } }
  class MountainMaterial extends THREE.MeshBasicMaterial{ constructor(){ super({ color:COLOR_PALETTE.black }); } }

  class CustomMaterial extends THREE.MeshStandardMaterial{ onBeforeCompile(shader){ shader.uniforms.uTime={ value:0.0 }; shader.vertexShader=shader.vertexShader.replace("#include <uv_pars_vertex>",`varying vec2 vUv;\nuniform float uTime;`); shader.vertexShader=shader.vertexShader.replace("#include <uv_vertex>","vUv = uv;"); shader.fragmentShader=shader.fragmentShader.replace("varying vec3 vViewPosition;",`varying vec3 vViewPosition;\nvarying vec2 vUv;\nuniform float uTime;`); this.userData.shader=shader; } }
  class CustomTransparentMaterial extends CustomMaterial{ constructor(){ super({ transparent:true }); } }

  class RoadMaterial extends CustomTransparentMaterial{ onBeforeCompile(shader){ super.onBeforeCompile(shader); shader.fragmentShader=shader.fragmentShader.replace("#include <map_fragment>",`
            diffuseColor = ${COLOR_PALETTE_GLSL.black};
            float width = 0.06;
            bool isInCenter = abs(0.5 - vUv.x) < (0.01 + width / 2.0);
            bool isInRoad = abs(0.5 - vUv.x) < (width / 2.0);
            if (isInCenter) { diffuseColor = ${COLOR_PALETTE_GLSL.color9}; }
            if (isInRoad) {
                diffuseColor = ${COLOR_PALETTE_GLSL.black};
                diffuseColor.a = 0.8;
                bool isInLine = (abs(0.5 - vUv.x + width / 6.0) < 0.0003);
                bool isInDashedLine = (abs(0.5 - vUv.x - width / 6.0) < 0.0003) && (sin(100.0 * vUv.y - 10.0 * uTime) > 0.3);
                if (isInLine || isInDashedLine) { diffuseColor = ${COLOR_PALETTE_GLSL.color10}; }
            }`); this.userData.shader=shader; } }

  class SunMaterial extends CustomTransparentMaterial{ onBeforeCompile(shader){ super.onBeforeCompile(shader); shader.fragmentShader=shader.fragmentShader.replace("#include <map_fragment>",`
            diffuseColor = vec4(0.0);
            bool isInSun = distance(vUv.xy, vec2(0.5, 0.5)) < 0.5;
            if (isInSun) {
                diffuseColor = ${COLOR_PALETTE_GLSL.color1};
                float delta = 0.2 * (1.0 - vUv.y);
                diffuseColor += vec4(delta, delta, 0.0, 0.0);
                bool isInLine = sin(100.0 * vUv.y) * vUv.y > 0.3;
                if (isInLine) { diffuseColor = ${COLOR_PALETTE_GLSL.color3}; }
            }`); this.userData.shader=shader; } }

  // ===== Bina malzemeleri (emissive) =====
  class BuildingMaterialA extends CustomMaterial{ onBeforeCompile(shader){ super.onBeforeCompile(shader);
    shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `
      diffuseColor = ${COLOR_PALETTE_GLSL.black};
      bool isInWindowA = vUv.y > 0.09 && (sin(31.415 * (vUv.x - 0.05)) > 0.5) && (sin(100.0 * vUv.y) > 0.5);
      if (isInWindowA) { diffuseColor = ${COLOR_PALETTE_GLSL.color7}; if (vUv.x > 0.4 && vUv.x < 0.6) { diffuseColor = ${COLOR_PALETTE_GLSL.color10}; } }
    `);
    shader.fragmentShader = shader.fragmentShader.replace("#include <emissivemap_fragment>", `
      #include <emissivemap_fragment>
      float winMaskA = (vUv.y > 0.09 && (sin(31.415 * (vUv.x - 0.05)) > 0.5) && (sin(100.0 * vUv.y) > 0.5)) ? 1.0 : 0.0;
      vec3  winColA  = ${COLOR_PALETTE_GLSL.color7}.rgb;
      totalEmissiveRadiance += winMaskA * winColA * 2.4;
    `); this.userData.shader=shader; } }
  class BuildingMaterialB extends CustomMaterial{ onBeforeCompile(shader){ super.onBeforeCompile(shader);
    shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `
      diffuseColor = ${COLOR_PALETTE_GLSL.black};
      bool isInWindowB = vUv.y > 0.1 && vUv.y < 0.5 && (sin(50.0 * 3.1415 * (vUv.x - 0.05)) > -0.8) && (sin(50.0 * vUv.y) > 0.5);
      if (isInWindowB) { diffuseColor = ${COLOR_PALETTE_GLSL.color1}; if (vUv.y < 0.3) { diffuseColor = ${COLOR_PALETTE_GLSL.color4}; } }
    `);
    shader.fragmentShader = shader.fragmentShader.replace("#include <emissivemap_fragment>", `
      #include <emissivemap_fragment>
      float winMaskB = (vUv.y > 0.1 && vUv.y < 0.5 && (sin(50.0 * 3.1415 * (vUv.x - 0.05)) > -0.8) && (sin(50.0 * vUv.y) > 0.5)) ? 1.0 : 0.0;
      vec3  winColB  = (vUv.y < 0.3) ? ${COLOR_PALETTE_GLSL.color4}.rgb : ${COLOR_PALETTE_GLSL.color1}.rgb;
      totalEmissiveRadiance += winMaskB * winColB * 2.4;
    `); this.userData.shader=shader; } }
  class BuildingMaterialC extends CustomMaterial{ onBeforeCompile(shader){ super.onBeforeCompile(shader);
    shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `
      diffuseColor = ${COLOR_PALETTE_GLSL.black};
      bool isInWindowC = vUv.y > 0.5 && vUv.y < 0.8 && (sin(5.0 * 3.1415 * (vUv.x - 0.05)) > -0.8) && (sin(50.0 * vUv.y) > 0.5);
      if (isInWindowC) { diffuseColor = ${COLOR_PALETTE_GLSL.color9}; }
    `);
    shader.fragmentShader = shader.fragmentShader.replace("#include <emissivemap_fragment>", `
      #include <emissivemap_fragment>
      float winMaskC = (vUv.y > 0.5 && vUv.y < 0.8 && (sin(5.0 * 3.1415 * (vUv.x - 0.05)) > -0.8) && (sin(50.0 * vUv.y) > 0.5)) ? 1.0 : 0.0;
      vec3  winColC  = ${COLOR_PALETTE_GLSL.color9}.rgb;
      totalEmissiveRadiance += winMaskC * winColC * 2.4;
    `); this.userData.shader=shader; } }
  class BuildingMaterialD extends CustomMaterial{ onBeforeCompile(shader){ super.onBeforeCompile(shader);
    shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `
      diffuseColor = ${COLOR_PALETTE_GLSL.black};
      bool isInWindowD = vUv.y > 0.1 && (sin(50.0 * vUv.y) > -0.8);
      if (isInWindowD) { diffuseColor = ${COLOR_PALETTE_GLSL.color5}; }
    `);
    shader.fragmentShader = shader.fragmentShader.replace("#include <emissivemap_fragment>", `
      #include <emissivemap_fragment>
      float winMaskD = (vUv.y > 0.1 && (sin(50.0 * vUv.y) > -0.8)) ? 1.0 : 0.0;
      vec3  winColD  = ${COLOR_PALETTE_GLSL.color5}.rgb;
      totalEmissiveRadiance += winMaskD * winColD * 2.4;
    `); this.userData.shader=shader; } }

  class MaterialsLibrary{ static default=new DefaultMaterial(); static road=new RoadMaterial(); static sun=new SunMaterial(); static mountain=new MountainMaterial(); static car=new CarMaterial(); static wheel=new WheelMaterial(); static light=new LightMaterial(); static buildingA=new BuildingMaterialA(); static buildingB=new BuildingMaterialB(); static buildingC=new BuildingMaterialC(); static buildingD=new BuildingMaterialD(); }

  // ====== OBJECTS ======
  class Road extends THREE.Group{
    constructor(){
      super();
      const g=new THREE.PlaneGeometry();
      const m=MaterialsLibrary.road;
      const road=new THREE.Mesh(g,m);
      road.scale.set(200,200,1);
      road.rotation.set(-Math.PI/2,0,0);
      if(FLAGS.ENABLE_SHADOWS){ road.receiveShadow=true; }
      this.add(road);

      // MOBILE: yansƒ±ma kapalƒ±
      if(!IS_MOBILE_DEVICE){
        const refl=new THREE.Reflector(new THREE.PlaneGeometry(10,10),{
          color:new THREE.Color(0x7f7f7f),
          textureWidth: window.innerWidth*window.devicePixelRatio,
          textureHeight: window.innerHeight*window.devicePixelRatio
        });
        refl.position.set(0,-0.1,0);
        refl.scale.set(200,200,1);
        refl.rotation.set(-Math.PI/2,0,0);
        this.add(refl);
      }
    }
  }

  class Sun extends THREE.Group{ constructor(){ super(); const g=new THREE.PlaneGeometry(); const m=MaterialsLibrary.sun; const s=new THREE.Mesh(g,m); s.scale.set(50,50,1); this.add(s); } }
  class Mountain extends THREE.Group{ constructor(){ super(); const m=MaterialsLibrary.mountain; const shape=new THREE.Shape(); shape.moveTo(0,0); shape.lineTo(100,0); shape.lineTo(100,50); shape.lineTo(50,10); shape.lineTo(20,15); shape.lineTo(15,5); shape.lineTo(10,10); shape.lineTo(0,0); shape.lineTo(-5,3); shape.lineTo(-10,10); shape.lineTo(-12,8); shape.lineTo(-100,50); shape.lineTo(-100,0); shape.lineTo(0,0); const g=new THREE.ExtrudeGeometry(shape); const mountain=new THREE.Mesh(g,m); this.add(mountain); } }

  // ====== Player Car ======
  class Car extends THREE.Group{
    constructor(){
      super();
      // Body
      { const m=MaterialsLibrary.car; const shape=new THREE.Shape();
        shape.moveTo(0,0); shape.lineTo(4,0); shape.lineTo(3.8,0.3); shape.lineTo(-0.1,0.7); shape.lineTo(0,0);
        const g=new THREE.ExtrudeGeometry(shape,{ depth:1.5, bevelThickness:0.2 });
        const body=new THREE.Mesh(g,m); body.position.set(0,0.3,0); this.add(body); }
      // Roof
      { const m=MaterialsLibrary.car; const g=new THREE.CylinderGeometry(0.6,1.2,0.5,4);
        const roof=new THREE.Mesh(g,m); roof.position.set(1.5,1,0.8); roof.rotation.set(0,Math.PI/4,0); this.add(roof); }
      // Lamps + fog
      { const stopMat = MaterialsLibrary.light.clone();
        stopMat.color.set(0xff2a10); stopMat.emissive.set(0xff2a10); stopMat.emissiveIntensity=1.8;
        const addLamp=(x,y,z,R,T)=>{ const outer=new THREE.Mesh(new THREE.TorusGeometry(R,T,20,48),stopMat); outer.rotation.y=Math.PI/2; outer.position.set(x,y,z); this.add(outer);
          const inner=new THREE.Mesh(new THREE.TorusGeometry(R*0.72,T*0.60,16,40),stopMat); inner.rotation.y=Math.PI/2; inner.position.set(x,y,z); this.add(inner); };
        const X=-0.17, Y=0.86;
        addLamp(X,Y,0.00,0.13,0.022); addLamp(X,Y,0.32,0.11,0.020);
        addLamp(X,Y,1.20,0.11,0.020); addLamp(X,Y,1.52,0.13,0.022);
        const fog=new THREE.Mesh(new THREE.BoxGeometry(0.26,0.06,0.02),stopMat); fog.position.set(-0.10,0.42,0.76); this.add(fog); }
      // Spoiler
      { const metal=new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.85, roughness:0.25 });
        const wingSpan=1.85, wingDepth=0.22, wingThick=0.06; const wingY=1.30, wingX=0.10, wingZ=0.76;
        const wing=new THREE.Mesh(new THREE.BoxGeometry(wingDepth,wingThick,wingSpan),metal); wing.position.set(wingX,wingY,wingZ); this.add(wing);
        const plateGeo=new THREE.BoxGeometry(0.20,0.32,0.02);
        const plateLft=new THREE.Mesh(plateGeo,metal); plateLft.position.set(wingX-0.04,wingY,wingZ-wingSpan/2+0.03); this.add(plateLft);
        const plateRgt=plateLft.clone(); plateRgt.position.z=wingZ+wingSpan/2-0.03; this.add(plateRgt);
        const legH=0.50; const legGeo=new THREE.BoxGeometry(0.10,legH,0.08); const legY=wingY-(wingThick/2)-(legH/2);
        const legLft=new THREE.Mesh(legGeo,metal); legLft.position.set(wingX-0.12,legY,wingZ-0.42); this.add(legLft);
        const legRgt=legLft.clone(); legRgt.position.z=wingZ+0.42; this.add(legRgt); }
      // Quad exhaust + flames (aynƒ±)
      { const pipeMat=new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.95, roughness:0.28 });
        pipeMat.onBeforeCompile=(shader)=>{ shader.uniforms.gradA={value:new THREE.Color(0x2b2b2b)};
          shader.uniforms.gradB={value:new THREE.Color(0x9a9a9a)};
          shader.vertexShader=shader.vertexShader.replace('#include <uv_pars_vertex>','varying vec2 vUv;').replace('#include <uv_vertex>','vUv = uv;');
          shader.fragmentShader=shader.fragmentShader.replace('#include <color_fragment>',`
            #include <color_fragment>
            vec3 grad = mix( gradA.rgb, gradB.rgb, vUv.y );
            diffuseColor.rgb = grad;`); };
        const tipOrange=MaterialsLibrary.light.clone(); tipOrange.color.set(0xff7a3a); tipOrange.emissive.set(0xff7a3a); tipOrange.emissiveIntensity=0.06;
        const tipBlue=MaterialsLibrary.light.clone(); tipBlue.color.set(0x79d4ff); tipBlue.emissive.set(0x79d4ff); tipBlue.emissiveIntensity=0.04;
        const flameOMat=new THREE.MeshBasicMaterial({ color:0xff7a3a, transparent:true, opacity:0, blending:THREE.AdditiveBlending, depthWrite:false });
        const flameBMat=new THREE.MeshBasicMaterial({ color:0x4cc9f0, transparent:true, opacity:0, blending:THREE.AdditiveBlending, depthWrite:false });
        const rOuter=0.085, len=0.12; const x=-0.22, y=0.34; const zs=[0.10,0.28,1.24,1.42];
        const exhaust=[]; const makePipe=(z)=>{ const pipe=new THREE.Mesh(new THREE.CylinderGeometry(rOuter,rOuter,len,32),pipeMat);
            pipe.rotation.z=Math.PI/2; pipe.position.set(x,y,z); this.add(pipe);
            const tipO=new THREE.Mesh(new THREE.CircleGeometry(rOuter*0.72,24),tipOrange); tipO.rotation.y=-Math.PI/2; tipO.position.set(x-len/2-0.001,y,z); this.add(tipO);
            const tipB=new THREE.Mesh(new THREE.CircleGeometry(rOuter*0.72,24),tipBlue); tipB.rotation.y=-Math.PI/2; tipB.position.set(x-len/2-0.001,y,z); tipB.visible=false; this.add(tipB);
            const flameO=new THREE.Mesh(new THREE.ConeGeometry(rOuter*0.85,len*0.6,14,1,true),flameOMat); flameO.rotation.z=-Math.PI/2; flameO.position.set(x-len/2-0.02,y,z); this.add(flameO);
            const flameB=new THREE.Mesh(new THREE.ConeGeometry(rOuter*0.85,len*0.6,14,1,true),flameBMat); flameB.rotation.z=-Math.PI/2; flameB.position.set(x-len/2-0.02,y,z); this.add(flameB);
            exhaust.push({ tipO,tipB,flameO,flameB, state:{ active:false, t0:0, duration:0, color:'orange' } }); };
        zs.forEach(makePipe); this.userData.exhaust=exhaust; }
      // Wheels
      { const m=MaterialsLibrary.wheel; const g=new THREE.CylinderGeometry(1,1,1,12);
        const w1=new THREE.Mesh(g,m); w1.scale.set(0.33,2,0.33); w1.position.set(3,0.33,0.75); w1.rotation.set(Math.PI/2,0,0); this.add(w1);
        const w2=new THREE.Mesh(g,m); w2.scale.set(0.33,2,0.33); w2.position.set(0.7,0.33,0.75); w2.rotation.set(Math.PI/2,0,0); this.add(w2); }
    }
  }

  // ====== NPC ======
  class ParkedCar extends THREE.Group{
    constructor(){
      super();
      const bodyMat = MaterialsLibrary.car.clone(); bodyMat.color.set(0x1a1a1a); bodyMat.roughness = 0.6; bodyMat.metalness = 0.2;
      const wheelMat = MaterialsLibrary.wheel;
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.22,0.44,2.18), bodyMat); body.position.y = 0.44; this.add(body);
      const roof = new THREE.Mesh(new THREE.BoxGeometry(0.86,0.32,0.96), bodyMat); roof.position.set(0,0.84,-0.18); this.add(roof);
      const wg = new THREE.CylinderGeometry(0.22,0.22,0.26,14); wg.rotateZ(Math.PI/2);
      const mkW=(x,z)=>{ const w=new THREE.Mesh(wg, wheelMat); w.position.set(x,0.22,z); return w; };
      this.add(mkW( 0.52,  0.74)); this.add(mkW(-0.52,  0.74)); this.add(mkW( 0.52, -0.74)); this.add(mkW(-0.52, -0.74));
      const stop = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.08,0.02), new THREE.MeshBasicMaterial({color:0xff3a2a})); stop.position.set(0,0.62,1.10); this.add(stop);
      const headMat = new THREE.MeshStandardMaterial({ color:0xfff6e5, emissive:0xfff6e5, emissiveIntensity:1.15, roughness:0.25, metalness:0.0 });
      const headL = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.14,0.03), headMat); headL.position.set(-0.36,0.62,-1.06); this.add(headL);
      const headR = headL.clone(); headR.position.x = +0.36; this.add(headR);
      const grill = new THREE.Mesh(new THREE.BoxGeometry(0.42,0.10,0.03), new THREE.MeshStandardMaterial({ color:0x202020, metalness:0.5, roughness:0.5 })); grill.position.set(0,0.52,-1.07); this.add(grill);
      this.rotation.y = 0;
      if(FLAGS.ENABLE_SHADOWS){ this.traverse(o=>{ if(o.isMesh){ o.castShadow = o.receiveShadow = true; } }); }
      this.userData.vFactor = 0.88 + Math.random()*0.30;
    }
  }

  // Poisson
  function sampleExp(mean){ return -Math.log(1-Math.random()) * mean; }

  class ParkedTraffic extends THREE.Group{
    constructor(laneX, isLeft, laneId){
      super();
      this._laneX = laneX; this._isLeft = !!isLeft;
      this._laneId = laneId || 'X';
      this._cars=[]; this._enabled=true;

      this._spawnMin = PARKED_SPAWN_MIN_SEC;
      this._spawnMean = PARKED_SPAWN_MEAN + (Math.random()*0.8 - 0.4);
      this._burstChance = PARKED_BURST_CHANCE;
      this._maxCars = PARKED_MAX;

      this._policy = null;
      this._nextSpawnAt = (performance.now()/1000) + sampleExp(this._spawnMean);
    }
    setSpawnPolicy(p){ this._policy = p; }
    setEnabled(b){ this._enabled = !!b; }
    clearAll(){ for(let i=this._cars.length-1;i>=0;i--){ this.remove(this._cars[i]); } this._cars.length=0; }

    _spawnAt(zBase){
      const c = new ParkedCar();
      const jitter = (Math.random()*0.14) - 0.12;
      const baseX = clampLaneX(this._laneX + jitter, this._isLeft);
      c.position.set(baseX, 0, zBase);
      c.rotation.y = 0;
      this._cars.push(c); this.add(c);
      c.userData._wasAhead = true;
      c.userData._passedBoost = false;
      if(FLAGS.ENABLE_SHADOWS){ c.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; } }); }
    }

    _trySpawn(now){
      if(this._cars.length >= this._maxCars) return;
      const z0 = 190 + Math.random()*30;

      if(this._policy){
        if(!this._policy.reserve(this._laneId, z0) || !this._policy.canSpawn(this._laneId, z0)){
          this._nextSpawnAt = now + 0.6 + Math.random()*0.8;
          return;
        }
      }
      this._spawnAt(z0);

      if(Math.random() < this._burstChance && this._cars.length < this._maxCars){
        const z1 = z0 + PARKED_BURST_GAP + Math.random()*6.0;
        if(this._policy){
          if(this._policy.reserve(this._laneId, z1) && this._policy.canSpawn(this._laneId, z1)){
            this._spawnAt(z1);
          }
        } else {
          this._spawnAt(z1);
        }
      }

      this._nextSpawnAt = now + sampleExp(this._spawnMean);
    }

    update(speed=1){
      if(this._enabled){
        const now = performance.now()/1000;
        if(now >= this._nextSpawnAt){
          this._trySpawn(now);
        }
      }
      for(let i=this._cars.length-1;i>=0;i--){
        const c=this._cars[i];
        const vf = c.userData.vFactor || 1.0;
        c.position.z -= 0.5 * speed * vf;
        if(c.position.z < 0){ this.remove(c); this._cars.splice(i,1); }
      }
    }
    getCars(){ return this._cars; }
  }

  class ParkedTrafficMiddle extends ParkedTraffic{
    constructor(laneX){ super(laneX, false, 'C'); }
    _spawnAt(zBase){
      const c = new ParkedCar();
      const jitter = (Math.random()*0.30) - 0.15;
      const baseX = this._laneX + jitter;
      c.position.set(baseX, 0, zBase);
      c.rotation.y = 0;
      this._cars.push(c); this.add(c);
      c.userData._wasAhead = true;
      c.userData._passedBoost = false;
      if(FLAGS.ENABLE_SHADOWS){ c.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; } }); }
      c.userData.vFactor = 0.9 + Math.random()*0.28;
    }
  }

  // Buildings & Stars
  class BuildingA extends THREE.Group{ constructor(){ super(); const m=MaterialsLibrary.buildingA; const g=new THREE.BoxGeometry(); const b=new THREE.Mesh(g,m); b.scale.set(10,15,10); b.position.set(0,-3,0); if(FLAGS.ENABLE_SHADOWS){ b.castShadow=true; } this.add(b); const rg=new THREE.ConeGeometry(5,15,7); const r=new THREE.Mesh(rg,m); r.position.set(0,5,0); this.add(r); } }
  class BuildingB extends THREE.Group{ constructor(){ super(); const m=MaterialsLibrary.buildingB; const g=new THREE.CylinderGeometry(); const b=new THREE.Mesh(g,m); b.scale.set(5,15,5); b.position.set(0,-3,0); if(FLAGS.ENABLE_SHADOWS){ b.castShadow=true; } this.add(b); const rg=new THREE.SphereGeometry(7); const r=new THREE.Mesh(rg,m); r.position.set(0,2,0); r.rotation.set(0,0.3,0); this.add(r); } }
  class BuildingC extends THREE.Group{ constructor(){ super(); const m=MaterialsLibrary.buildingC; const g=new THREE.BoxGeometry(); const b=new THREE.Mesh(g,m); b.scale.set(5,5,5); b.position.set(0,-8,0); if(FLAGS.ENABLE_SHADOWS){ b.castShadow=true; } this.add(b); } }
  class BuildingD extends THREE.Group{ constructor(){ super(); const m=MaterialsLibrary.buildingD; const g=new THREE.ConeGeometry(1,1,3); const b=new THREE.Mesh(g,m); b.scale.set(5,20,5); b.rotation.set(0,1,0); if(FLAGS.ENABLE_SHADOWS){ b.castShadow=true; } this.add(b); } }

  class City extends THREE.Group{
    static #getRandomBuilding(){ const c=Math.random(); if(c<0.2) return new BuildingA(); if(c<0.3) return new BuildingB(); if(c<0.9) return new BuildingC(); return new BuildingD(); }
    constructor(){
      super();
      const ZSTEP = IS_MOBILE_DEVICE ? 30 : 20;        // MOBILE: daha seyrek
      const XSTEP = IS_MOBILE_DEVICE ? 40 : 20;        // MOBILE: daha seyrek
      for(let z=0; z<200; z+=ZSTEP){
        for(let x=70; x>=10; x-=XSTEP){ this.#initBuilding(x,z); }
        for(let x=120; x<=180; x+=XSTEP){ this.#initBuilding(x,z); }
      }
    }
    #initBuilding(x,z){ const b=City.#getRandomBuilding(); b.position.set(x,20/2,z); this.add(b); }
    update(speed=1){ this.children.forEach((b)=>{ const {x,z}=b.position; let newZ=z-0.5*speed; if(newZ<0){ newZ=200; } const y = newZ <= 150 ? 10 : 10 + 20 * ((150 - newZ) / 50); b.position.set(x,y,newZ); }); }
  }

  class Stars extends THREE.Group{
    constructor(){
      super();
      const g=new THREE.SphereGeometry();
      const m=MaterialsLibrary.light;
      const STEP_X = IS_MOBILE_DEVICE ? 60 : 30;   // MOBILE: seyrek
      const STEP_Y = IS_MOBILE_DEVICE ? 60 : 30;
      for(let x=-300; x<300; x+=STEP_X){
        for(let y=0; y<300; y+=STEP_Y){
          const s=new THREE.Mesh(g,m.clone());
          const dx=25*Math.random(); const dy=25*Math.random(); const sc=Math.random();
          s.scale.set(sc,sc,sc); s.position.set(x+dx,y+dy,0); this.add(s);
        }
      }
    }
    setOpacity(a){ this.children.forEach(m=>{ if(m.material && m.material.transparent){ m.material.opacity = a; } }); }
  }

  class ObjectsLibrary{
    static road=new Road();
    static sun=new Sun();
    static mountain=new Mountain();
    static car=new Car();
    static city=new City();
    static stars=new Stars();
    static parkedLeft   = new ParkedTraffic(PARKED_LANE_X_LEFT,  true,  'L');
    static parkedRight  = new ParkedTraffic(PARKED_LANE_X_RIGHT, false, 'R');
    static parkedCenter = new ParkedTrafficMiddle(PARKED_LANE_X_MIDDLE);
  }

  // ====== WORLD ======
  class SandboxWorld extends THREE.Group{
    #saved;
    constructor(onCrashCb, onLaneChangeCb, onMakasCb, onBoostOvertakeCb){
      super();
      this._carTargetX = CAR_BASE_X;
      this._onCrashCb = onCrashCb || null;
      this._onLaneChange = onLaneChangeCb || null;
      this._onMakas = onMakasCb || null;
      this._lastLaneChangeTime = 0;
      this._lane = 0;
      this._lastMakasTime = 0;
      this._difficulty = 1.0;
      this._crashLock = false;
      this._boost = false; this._lastBurst = 0; this._nextBurstDelay = 0.30;
      this._tmpBoxPlayer = new THREE.Box3();
      this._tmpBoxNPC = new THREE.Box3();
      this._roundStartEpoch = performance.now()/1000;
      this._spawnWaves = [];
      this._onBoostOvertake = onBoostOvertakeCb || null;
      this._frozenElapsedSec = 0;
      this._boostLevel = 0;
      this._lastT = performance.now()/1000;

      this.#initObjects();
      this.#initLights();
      this.#initHeadlights();
    }

    _getElapsed(){ return (performance.now()/1000) - this._roundStartEpoch; }
    _hasCarNear(laneObj, z, win){ const arr = laneObj.getCars(); for(const c of arr){ if(Math.abs(c.position.z - z) < win) return true; } return false; }
    _canSpawn(laneId, z){
      const elapsed = this._getElapsed();
      const win = elapsed < 30 ? 22 : (elapsed < 60 ? 18 : 14);
      let occ = 0;
      const L=this.#saved.parkedLeft, C=this.#saved.parkedCenter, R=this.#saved.parkedRight;
      if(laneId!=='L' && this._hasCarNear(L, z, win)) occ++;
      if(laneId!=='C' && this._hasCarNear(C, z, win)) occ++;
      if(laneId!=='R' && this._hasCarNear(R, z, win)) occ++;
      return occ <= 1;
    }

    _checkBoostOvertakes(){
      if(!this._boost) return;
      const player = this.#saved.car;
      const px = player.position.x;
      const pz = player.position.z;
      const pLane = this._laneFromX(px);

      const lanes = [this.#saved.parkedLeft, this.#saved.parkedCenter, this.#saved.parkedRight];
      for(const lane of lanes){
        const arr = lane.getCars();
        for(const c of arr){
          const aheadNow = (c.position.z > pz);
          if(c.userData._wasAhead && !aheadNow && !c.userData._passedBoost){
            const cLane = this._laneFromX(c.position.x);
            const isNear = Math.abs(pLane - cLane) <= 1;
            if(isNear){
              c.userData._passedBoost = true;
              if(this._onBoostOvertake){ this._onBoostOvertake(); }
            } else {
              c.userData._passedBoost = true;
            }
          }
          c.userData._wasAhead = aheadNow;
        }
      }
    }

    _getWallBand(){ const e = this._getElapsed(); if(e < 30) return 26; if(e < 60) return 20; return 16; }
    _reserveSpawn(laneId, z){
      const now  = performance.now()/1000;
      const band = this._getWallBand();
      this._spawnWaves = this._spawnWaves.filter(w => (now - w.t) < 8.0);
      let wave = this._spawnWaves.find(w => Math.abs(w.z - z) <= band);
      if(!wave){ wave = { z, t: now, lanes: new Set() }; this._spawnWaves.push(wave); }
      if(!wave.lanes.has(laneId) && wave.lanes.size >= 2){ return false; }
      wave.lanes.add(laneId); return true;
    }

    #initObjects(){
      const {road,car,sun,city,mountain,stars, parkedLeft, parkedRight, parkedCenter}=ObjectsLibrary;
      // Arabayƒ± biraz k√º√ß√ºlt (1 = orijinal)
      const CAR_SCALE = 0.9; // √∂rnek: %90
      car.scale.set(CAR_SCALE, CAR_SCALE, CAR_SCALE);

      road.position.set(0,0,100);
      sun.position.set(0,-15,200); sun.rotation.set(-Math.PI,0,0);
      city.position.set(-100,0,0);
      mountain.position.set(0,0,200);
      car.position.set(CAR_BASE_X,0,10); car.rotation.set(0,-Math.PI/2,0);
      stars.position.set(0,0,250);
      this.add(road,sun,car,city,mountain,stars, parkedLeft, parkedRight, parkedCenter);
      this.#saved={ car, city, sun, stars, parkedLeft, parkedRight, parkedCenter };
      this._lane = this._laneFromX(car.position.x);

      const policy = { reserve : (laneId, z) => this._reserveSpawn(laneId, z), canSpawn: (laneId, z) => this._canSpawn(laneId, z) };
      parkedLeft.setSpawnPolicy(policy);
      parkedCenter.setSpawnPolicy(policy);
      parkedRight.setSpawnPolicy(policy);
    }

    #initLights(){
      const ambient = new THREE.AmbientLight(COLOR_PALETTE.color3, NIGHT_AMBIENT); this.add(ambient);
      const point = new THREE.PointLight(COLOR_PALETTE.color1, NIGHT_POINT, 300, 0.5); point.position.set(0,30,180);
      if(FLAGS.ENABLE_SHADOWS){ point.castShadow=true; } this.add(point);
      this._ambient = ambient; this._point = point;
    }

    #initHeadlights(){
      const mkLight = (xOffset)=>{
        const color = 0xfff6e5;
        const light = new THREE.SpotLight(color, 26, 64, Math.PI*0.10, 0.35, 2.2);
        light.castShadow = !!FLAGS.ENABLE_SHADOWS;
        light.shadow.mapSize.set(1024,1024);
        light.shadow.bias = -0.00008;
        const target = new THREE.Object3D(); this.add(target); light.target = target;
        return { light, target, xOffset, base:{ intensity: light.intensity, distance: light.distance, angle: light.angle } };
      };
      const left = mkLight(-0.45);

      if(IS_MOBILE_DEVICE){
        const group = new THREE.Group(); group.add(left.light); this.add(group);
        this._headlights = { group, left, right:null };
      } else {
        const right = mkLight(+0.45); right.light.color.set(0xeef8ff);
        const group = new THREE.Group(); group.add(left.light, right.light); this.add(group);
        this._headlights = { group, left, right };
      }
    }

    setTrafficEnabled(b){
      this.#saved.parkedLeft.setEnabled(b);
      this.#saved.parkedCenter.setEnabled(b);
      this.#saved.parkedRight.setEnabled(b);
    }
    clearTraffic(){
      this.#saved.parkedLeft.clearAll();
      this.#saved.parkedCenter.clearAll();
      this.#saved.parkedRight.clearAll();
    }
    handleCrash(){
      if(this._crashLock) return;
      this._crashLock = true;
      this.setTrafficEnabled(false);
      this.clearTraffic();
      this._boost = false;
    }

    getCarX(){ return this.#saved.car.position.x; }
    isBoosting(){ return !!this._boost; }
    getBoostLevel(){ return this._boostLevel; }

    setBoost(active){ this._boost = active; }
    triggerExhaustBurst(){
      const ex = this.#saved.car.userData.exhaust; if(!ex) return;
      const now = performance.now()/1000;
      ex.forEach(p=>{
        p.state.active = true; p.state.t0 = now; p.state.duration = 0.09 + Math.random()*0.15; p.state.color = Math.random() < 0.6 ? 'orange' : 'blue';
        p.tipO.visible = (p.state.color === 'orange'); p.tipB.visible = (p.state.color === 'blue');
        p.flameO.material.opacity = 0.0; p.flameB.material.opacity = 0.0;
      });
      this._lastBurst = now;
    }

    enableHardMode(){
      if(this._difficulty >= 1.15) return;
      this._difficulty = 1.15;
      const lanes=[this.#saved.parkedLeft,this.#saved.parkedCenter,this.#saved.parkedRight];
      lanes.forEach(L=>{
        L._spawnMean = Math.max(1.3, L._spawnMean * 0.65);
        L._maxCars = Math.min(6, (L._maxCars || PARKED_MAX) + 2);
        L._burstChance = Math.min(0.45, (L._burstChance || PARKED_BURST_CHANCE) + 0.12);
      });
    }

    _laneFromX(x){
      const midLeft  = CAR_BASE_X - CAR_LANE_AMPLITUDE/2;
      const midRight = CAR_BASE_X + CAR_LANE_AMPLITUDE/2;
      if(x < midLeft) return -1;
      if(x > midRight) return +1;
      return 0;
    }

    _checkCollision(){
      if (this._crashLock) return;
      const player = this.#saved.car;
      this._tmpBoxPlayer.setFromObject(player);
      shrinkBox(this._tmpBoxPlayer, HITBOX_PLAYER);

      const lanes = [ this.#saved.parkedLeft.getCars(), this.#saved.parkedCenter.getCars(), this.#saved.parkedRight.getCars() ];
      for (const arr of lanes){
        for (const npc of arr){
          this._tmpBoxNPC.setFromObject(npc);
          shrinkBox(this._tmpBoxNPC, HITBOX_NPC);
          if (this._tmpBoxPlayer.intersectsBox(this._tmpBoxNPC)){
            this.handleCrash();
            if (typeof this._onCrashCb === 'function') this._onCrashCb();
            return;
          }
        }
      }
    }

    _checkMakas(){
      const now = performance.now()/1000;
      if((now - this._lastMakasTime) < 1.0) return;
      const player = this.#saved.car;
      const px = player.position.x, pz = player.position.z;
      const zTol = 1.1, xGap = 0.50;
      const all = [ ...this.#saved.parkedLeft.getCars(), ...this.#saved.parkedCenter.getCars(), ...this.#saved.parkedRight.getCars() ];
      let hasLeft=false, hasRight=false;
      for(const c of all){
        const dz = Math.abs(c.position.z - pz);
        if(dz <= zTol){
          if(c.position.x <= px - xGap) hasLeft = true;
          if(c.position.x >= px + xGap) hasRight = true;
          if(hasLeft && hasRight) break;
        }
      }
      if(hasLeft && hasRight){
        this._lastMakasTime = now;
        if(typeof this._onMakas === 'function'){ this._onMakas(); }
      }
    }

    update(){
      const t = performance.now()/1000;
      const dt = Math.max(0, t - (this._lastT ?? t));
      this._lastT = t;

      // Boost ramp
      if (this._boost) { this._boostLevel = Math.min(1, this._boostLevel + dt / BOOST_RAMP_UP_SEC); }
      else             { this._boostLevel = Math.max(0, this._boostLevel - dt / BOOST_RAMP_DOWN_SEC); }

      const car = this.#saved.car;

      // X konum/tilt
      const desired = this._carTargetX;
      car.position.x += (desired - car.position.x) * CAR_LERP;
      car.position.x += 0.02 * Math.sin(t*2.0);
      const steer = THREE.MathUtils.clamp((desired - car.position.x), -1, 1);
      car.rotation.z = THREE.MathUtils.lerp(car.rotation.z, -CAR_BANK_MAX * steer, 0.15);

      // Hƒ±zlar
      const speedMult = 1.0 + (BOOST_TARGET_MULT - 1.0) * this._boostLevel;
      this.#saved.city.update(CITY_BASE_SPEED * speedMult * this._difficulty);
      this.#saved.parkedLeft.update(LANE_SPEED.LEFT   * speedMult * this._difficulty);
      this.#saved.parkedCenter.update(LANE_SPEED.CENTER * speedMult * this._difficulty);
      this.#saved.parkedRight.update(LANE_SPEED.RIGHT * speedMult * this._difficulty);
      this._checkBoostOvertakes();

      // Far hedefleri
      if(this._headlights){
        const { left, right } = this._headlights;
        const baseX = car.position.x; const baseY = 0.62; const baseZ = car.position.z + 1.15; const aheadZ = car.position.z + 22;
        if(left){
          left.light.position.set(baseX + left.xOffset, baseY, baseZ);
          left.target.position.set(baseX + left.xOffset * 0.6, baseY - 0.06, aheadZ);
          left.light.target.updateMatrixWorld();
        }
        if(right){
          right.light.position.set(baseX + right.xOffset, baseY, baseZ);
          right.target.position.set(baseX + right.xOffset * 0.6, baseY - 0.06, aheadZ);
          right.light.target.updateMatrixWorld();
        }
      }

      // Boost sƒ±rasƒ±nda rastgele alev patlamalarƒ±
      if(this._boost){
        if( (t - this._lastBurst) > this._nextBurstDelay ){
          this.triggerExhaustBurst();
          this._nextBurstDelay = 0.18 + Math.random()*0.45;
        }
      }

      // Alev animasyonu
      const exhaust = car.userData.exhaust || [];
      for(const p of exhaust){
        const s = p.state; if(!s.active) continue;
        const u = (t - s.t0) / s.duration;
        if(u >= 1){
          s.active = false; p.flameO.material.opacity = 0; p.flameB.material.opacity = 0;
          p.tipO.material.emissiveIntensity = 0.06; p.tipB.material.emissiveIntensity = 0.04;
          p.tipO.visible = true; p.tipB.visible = false;
        } else {
          const e = Math.sin(u*Math.PI);
          const flame = s.color==='orange' ? p.flameO : p.flameB;
          const tip   = s.color==='orange' ? p.tipO   : p.tipB;
          flame.material.opacity = 0.85 * e;
          flame.scale.set(0.9 + 0.4*e, 0.8 + 0.5*e, 0.8 + 0.5*e);
          tip.material.emissiveIntensity = (s.color==='orange'?1.2:1.0)*e + (s.color==='orange'?0.06:0.04);
        }
      }

      // ≈ûerit deƒüi≈üim / Makas / √áarpƒ±≈üma
      const lane = this._laneFromX(car.position.x);
      if(lane !== this._lane){
        if((t - this._lastLaneChangeTime) > 0.35){
          this._lane = lane;
          this._lastLaneChangeTime = t;
          if(typeof this._onLaneChange === 'function'){ this._onLaneChange(); }
        }
      }
      this._checkMakas();
      this._checkCollision();
    }

    setSunriseProgress(p){
      const clamped = Math.max(0, Math.min(1, p));
      const sunY = -15 + (25 * clamped);
      this.#saved.sun.position.y = sunY;
      this.#saved.stars.setOpacity(1.0 - clamped);
      this._ambient.intensity = NIGHT_AMBIENT + (DAY_AMBIENT - NIGHT_AMBIENT) * clamped;
      this._point.intensity   = NIGHT_POINT + (DAY_POINT   - NIGHT_POINT)   * clamped;
      if(this._headlights){
        const f = 1 - THREE.MathUtils.smoothstep(clamped, 0.12, 0.80);
        const L = this._headlights.left?.light; const R = this._headlights.right?.light;
        if(L){ L.intensity = this._headlights.left.base.intensity * f; L.distance  = this._headlights.left.base.distance  * (0.6 + 0.4*f); L.visible = f > 0.02; }
        if(R){ R.intensity = this._headlights.right.base.intensity * f; R.distance = this._headlights.right.base.distance * (0.6 + 0.4*f); R.visible = f > 0.02; }
      }
    }
    setCarLaneTarget(x){
      const min = CAR_BASE_X - CAR_LANE_AMPLITUDE;
      const max = CAR_BASE_X + CAR_LANE_AMPLITUDE;
      this._carTargetX = Math.min(max, Math.max(min, x));
    }
  }

  // ====== UI helpers ======
  let __lastToastAt = 0; // MOBILE throttle
  function showToast(msg, opts={}){
    const now = performance.now();
    if (IS_MOBILE_DEVICE && now - __lastToastAt < 250) return;
    __lastToastAt = now;

    const c = document.getElementById('toasts'); if(!c) return;
    const el = document.createElement('div'); el.className='toast';
    if(opts.html){ el.innerHTML = msg; } else { el.textContent = msg; }
    c.appendChild(el);
    requestAnimationFrame(()=> el.classList.add('show'));
    setTimeout(()=>{ el.classList.remove('show'); setTimeout(()=> el.remove(), 250); }, 1200);
  }

  function showPointToast(label, delta){
    const html = `${label} <span class="points">+${delta} Puan</span>`;
    showToast(html, { html:true });
  }

  // ====== APP / GAME LOOP ======
  class FullScreen3DExample{
    static CSS_ROOT="full-screen-3d-example"; static CSS_ROOT_LOADED_VARIANT="-loaded";
    #root; #scene; #world; #camera; #cameraData; #renderer; #composer; #startTime; #noisePass;
    constructor(root){
      this.#root=root; this.#root.classList.add(FullScreen3DExample.CSS_ROOT);

      // Yardƒ±m & Ayarlar
      this._helpBtn    = document.getElementById('helpBtn');
      this._settingsBtn= document.getElementById('settingsBtn');
      this._helpPanel  = document.getElementById('helpPanel');

      this._helpBtn.addEventListener('click', ()=>{
        this._helpPanel.classList.toggle('hidden');
        if(!this._helpPanel.classList.contains('hidden')){ this._audioPanel?.classList.add('hidden'); }
      });
      this._settingsBtn.addEventListener('click', ()=>{
        if(this._audioPanel){
          const willOpen = this._audioPanel.classList.contains('hidden');
          this._audioPanel.classList.toggle('hidden');
          if(willOpen){ this._helpPanel?.classList.add('hidden'); }
        }
      });

      // ESC kapat
      document.addEventListener('keydown', (ev)=>{
        if(ev.key==='Escape'){ this._helpPanel?.classList.add('hidden'); this._audioPanel?.classList.add('hidden'); }
      });

      // === Audio ===
      this._boost = new Audio("https://cdn.prod.website-files.com/67fb1cd83af51c4fe96dacb2/69003b7a671ad7cf11b650a9_boost_speed.MP3");
      this._boost.loop = true; this._boost.preload = "auto"; this._boost.volume = 0.8; this._boostStarted = false;

      this._boostPop = new Audio("https://cdn.prod.website-files.com/67fb1cd83af51c4fe96dacb2/69001ef687d7fa183b58460a_boost.MP3");
      this._boostPop.preload = "auto"; this._boostPop.volume = 0.7;

      this._boostHoldStart = 0; this._boostPopPlayed = false;

      this._bgm = new Audio("https://cdn.prod.website-files.com/67fb1cd83af51c4fe96dacb2/68ffb4adf30691cf2d7ec738_Night%20Patrol.mp3");
      this._bgm.loop = true; this._bgm.preload = "auto"; this._bgm.volume = 0.6;

      this._engine = new Audio("https://cdn.prod.website-files.com/67fb1cd83af51c4fe96dacb2/69003db58dbf725d05302157_normalspeedv1.MP3");
      this._engine.loop = true; this._engine.preload = "auto"; this._engine.volume = 0.7;

      this._bgmStarted = false; this._engStarted = false;

      // Audio UI
      this._audioPanel = document.getElementById('audioPanel');
      this._bgmMuteBtn = document.getElementById('bgmMuteBtn');
      this._engMuteBtn = document.getElementById('engMuteBtn');
      this._bgmVol = document.getElementById('bgmVol');
      this._engVol = document.getElementById('engVol');

      this._bgmMuted = false; this._engMuted = false;

      // HUD
      this._hudScore = document.getElementById('hud-score');
      this._hudTime  = document.getElementById('hud-time');

      // Overlay
      this._overlay  = document.getElementById('overlay');
      this._btn      = document.getElementById('playBtn');
      this._ovlTitle = document.getElementById('ovlTitle');
      this._ovlDesc  = document.getElementById('ovlDesc');

      // State
      this._mode = 'IDLE';
      this._score = 0;
      this._gameStartEpoch = performance.now()/1000;
      this._hardMode = false;
      this._boostAcc = 0;
      this._lastNow = performance.now()/1000;

      this.#initScene();
      this.#initObjects();
      this.#initCamera();
      this.#initRenderer();
      this.#initComposer();
      this.#initEventListeners();
      this.#onWindowResize();
      this.#cacheAnimShaders();
      this.#root.classList.add(FullScreen3DExample.CSS_ROOT_LOADED_VARIANT);

      // Dinamik DPR vars
      this._dprMin = 0.65;
      this._dprMax = IS_MOBILE_DEVICE ? 1.1 : 2.0;
      this._dpr    = Math.min(window.devicePixelRatio||1, this._dprMax);
      this._fpsEMA = 60;
      this._lastFpsAdjust = performance.now()/1000;

      // Gece ba≈ülangƒ±cƒ±
      this.#startTime = performance.now()/1000;
      this._spaceDown=false;

      // IDLE: trafik kapalƒ±
      this.#world.setTrafficEnabled(false);
      this.showOverlay(true, 'start');

      this.start();
      this._updateHud();
    }

    _ensureBoostStarted(){
      if(this._boostStarted) return;
      this._boost.play().then(()=>{ this._boostStarted = true; }).catch(()=>{});
    }
    _setBoostAudioState(active){
      if(active){
        this._ensureBoostStarted();
        try { this._boost.currentTime = 0; } catch(_) {}
        this._boost.play().catch(()=>{});
        if(this._engStarted) this._engine.pause();
      }else{
        this._boost.pause();
        try { this._boost.currentTime = 0; } catch(_) {}
        if(!this._engMuted){
          this._ensureEngineStarted();
          this._engine.play().catch(()=>{});
        }
      }
      this._applyVolumes();
    }

    #initScene(){ this.#scene=new THREE.Scene(); }
    #initObjects(){
      this.#world=new SandboxWorld(
        ()=> this.onCrash(),
        ()=> { this._score += 1; this._updateHud(); showPointToast("≈ûerit deƒüi≈ütirme", 1); },
        ()=> { this._score += 1; this._updateHud(); showPointToast("Makas", 1); },
        ()=> this._onBoostOvertake()
      );
      this.#scene.add(this.#world);
    }

    #initCamera(){ const fov=45, aspect=window.innerWidth/window.innerHeight, near=1, far=1000; this.#camera=new THREE.PerspectiveCamera(fov,aspect,near,far); this.#camera.position.set(0,2,1); this.#camera.lookAt(0,0,200); this.#camera.updateProjectionMatrix(); this.#cameraData={ positionX:0, positionY:2, lookAtX:0 }; }
    #initRenderer(){
      const clearColor=COLOR_PALETTE.black, clearColorAlpha=1;
      const useLogDepth = !IS_MOBILE_DEVICE; // mobilde kapat
      this.#renderer=new THREE.WebGLRenderer({ alpha:true, logarithmicDepthBuffer: useLogDepth, antialias:false, powerPreference:'high-performance' });
      this.#renderer.setClearColor(clearColor, clearColorAlpha);
      const DPR_CAP = IS_MOBILE_DEVICE ? 1.1 : 2.0;
      this.#renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, DPR_CAP));
      this.#renderer.toneMapping = THREE.ACESFilmicToneMapping;
      this.#renderer.toneMappingExposure = 0.6;
      if(FLAGS.ENABLE_SHADOWS){ this.#renderer.shadowMap.enabled=true; this.#renderer.shadowMap.type=THREE.PCFSoftShadowMap; }
      this.#root.appendChild(this.#renderer.domElement);
    }
    #initComposer(){
      const width=window.innerWidth, height=window.innerHeight;
      this.#composer=new THREE.EffectComposer(this.#renderer);
      this.#composer.setSize(width,height);
      this.#initRenderPass();
      if(FLAGS.ENABLE_BLOOM){ this.#initBloomPass(); }
      if(FLAGS.ENABLE_NOISE){ this.#initShaderPass(); }
    }
    #initRenderPass(){ const renderPass=new THREE.RenderPass(this.#scene,this.#camera); this.#composer.addPass(renderPass); }
    #initBloomPass(){ const width=window.innerWidth, height=window.innerHeight; const resolution=new THREE.Vector2(width,height); const strength=0.8, radius=0.5, threshold=0.1; const bloomPass=new THREE.UnrealBloomPass(resolution,strength,radius,threshold); this.#composer.addPass(bloomPass); }
    #initShaderPass(){ const pass=new THREE.ShaderPass({ uniforms:{ tDiffuse:{ type:"t", value:null }, uTime:{ value:1 }, uStrength:{ value:1 } }, vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`, fragmentShader:`uniform float uTime; uniform float uStrength; uniform sampler2D tDiffuse; varying vec2 vUv; float rand(vec2 seed); float noise(vec2 position); void main(){ vec4 color=texture2D(tDiffuse, vUv); float d=uStrength * 0.05 * noise(50.0 * (100.0 * uTime + vec2(vUv.x, 20.0 * vUv.y))); color = vec4(color.r - d, color.g - d, color.b - d, 1.0); gl_FragColor=color; } float rand(vec2 seed){ return fract(sin(dot(seed, vec2(12.9898,78.233))) * 43758.5453123);} float noise(vec2 position){ vec2 blockPosition=floor(position); float tl=rand(blockPosition); float tr=rand(blockPosition+vec2(1.0,0.0)); float bl=rand(blockPosition+vec2(0.0,1.0)); float br=rand(blockPosition+vec2(1.0,1.0)); vec2 c=smoothstep(0.0,1.0,fract(position)); return mix(tl,tr,c.x) + (bl-tl)*c.y*(1.0-c.x) + (br-tr)*c.x*c.y; }` }); pass.renderToScreen=true; this.#composer.addPass(pass); this.#noisePass = pass; }
    #initEventListeners(){
      window.addEventListener("resize", this.#onWindowResize.bind(this));
      document.addEventListener("mousemove", this.#onMouseMove.bind(this));
      document.addEventListener("touchmove", (ev)=>{ 
        if(!ev.touches || !ev.touches[0]) return; 
        const x = ev.touches[0].clientX; 
        this.#updateCarTargetFromPointer(x); 
      }, {passive:true});

      // Klavye: Space ile boost
      document.addEventListener('keydown', (ev)=>{
        if(ev.code==='Space'){
          if(!this._spaceDown && this._mode==='RUNNING'){
            this._spaceDown=true;
            this.#world.setBoost(true);
            this.#world.triggerExhaustBurst();
            const now = performance.now()/1000; this._boostHoldStart = now; this._boostPopPlayed = false;
            this._setBoostAudioState(true);
          }
          ev.preventDefault();
        }
      });
      document.addEventListener('keyup', (ev)=>{
        if(ev.code==='Space'){
          this._spaceDown=false;
          this.#world.setBoost(false);
          this._boostHoldStart = 0; this._boostPopPlayed = false;
          this._setBoostAudioState(false);
          ev.preventDefault();
        }
      });

      // Mouse: Sol tƒ±k ile boost
      document.addEventListener('mousedown', (ev)=>{
        if(ev.button!==0) return;
        if(!this._spaceDown && this._mode==='RUNNING'){
          this._spaceDown = true;
          this.#world.setBoost(true);
          this.#world.triggerExhaustBurst();
          const now = performance.now()/1000; this._boostHoldStart = now; this._boostPopPlayed = false;
          this._setBoostAudioState(true);
          ev.preventDefault();
        }
      });
      document.addEventListener('mouseup', (ev)=>{
        if(ev.button!==0) return;
        this._spaceDown = false;
        this.#world.setBoost(false);
        this._boostHoldStart = 0; this._boostPopPlayed = false;
        this._setBoostAudioState(false);
      });

      window.addEventListener('blur', ()=>{
        this._spaceDown = false;
        this.#world.setBoost(false);
        this._boostHoldStart = 0; this._boostPopPlayed = false;
        this._setBoostAudioState(false);
      });

      this._btn.addEventListener('click', ()=> this.startRound());

      // M√ºzik mute
      this._bgmMuteBtn.addEventListener('click', ()=>{
        this._bgmMuted = !this._bgmMuted;
        this._updateAudioUi();
        if(!this._bgmStarted && !this._bgmMuted) this._ensureBgmStarted();
      });
      // Motor mute
      this._engMuteBtn.addEventListener('click', ()=>{
        this._engMuted = !this._engMuted;
        this._updateAudioUi();
        if(!this._engStarted && !this._engMuted) this._ensureEngineStarted();
      });
      // Ses d√ºzeyi
      this._bgmVol.addEventListener('input', ()=> this._applyVolumes());
      this._engVol.addEventListener('input', ()=> this._applyVolumes());
    }

    #onWindowResize(){ const width=window.innerWidth, height=window.innerHeight; this.#camera.aspect=width/height; this.#camera.updateProjectionMatrix(); this.#renderer.setSize(width,height); this.#composer.setSize(width,height); }
    #onMouseMove(e){
      this.#cameraData.positionX=(CAMERA_MOUSE_X_FACTOR*(window.innerWidth/2 - e.clientX))/window.innerWidth;
      this.#cameraData.positionY=2 + (0.5*(window.innerHeight/2 - e.clientY))/window.innerHeight;
      if(this._mode==='RUNNING'){ this.#updateCarTargetFromPointer(e.clientX); }
    }
    #updateCarTargetFromPointer(pointerX){
      const nx = pointerX / window.innerWidth; const centered = (nx - 0.5) * 2.0;
      const curved = Math.sign(centered) * Math.pow(Math.abs(centered), MOUSE_EXP);
      const target = CAR_BASE_X + curved * CAR_LANE_AMPLITUDE; this.#world.setCarLaneTarget(target);
    }

    showOverlay(show, reason=null){
      if(show){
        this._overlay.classList.remove('hidden');
        if(reason==='start'){ this._ovlTitle.textContent="Gece devriyesi üåô"; this._ovlDesc.textContent="Oyunu ba≈ülatmak i√ßin ‚ÄúBa≈üla‚Äùya bas."; this._btn.textContent="Ba≈üla"; }
        else if(reason==='crash'){ this._ovlTitle.textContent="Kaza! üöß"; this._ovlDesc.textContent="Tekrar ba≈ülatmak i√ßin ‚ÄúTekrar Oyna‚Äùya bas."; this._btn.textContent="Tekrar Oyna"; }
      } else { this._overlay.classList.add('hidden'); }
    }

    _formatTime(sec){ const m = Math.floor(sec/60); const s = Math.floor(sec%60); const tenth = Math.floor((sec - Math.floor(sec))*10); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${tenth}`; }
    _updateHud(){
      this._hudScore.textContent = `Puan: ${this._score}`;
      let elapsed;
      if (this._mode === 'RUNNING') {
        const now = performance.now()/1000;
        elapsed = Math.max(0, now - this._gameStartEpoch);
      } else {
        elapsed = this._frozenElapsedSec;
      }
      this._hudTime.textContent = `S√ºre: ${this._formatTime(elapsed)}`;
    }

    addScore(x, toastMsg){
      if(this._mode!=='RUNNING') return;
      this._score += x; this._updateHud();
      if(toastMsg) showToast(toastMsg);
    }

    _onBoostOvertake(){ this._score += 3; this._updateHud(); showPointToast("Ge√ßi≈ü (Boost)", 3); }

    onCrash(){
      const now = performance.now()/1000;
      this._frozenElapsedSec = now - this._gameStartEpoch;

      this.#world.handleCrash();
      this._spaceDown = false; this.#world.setBoost(false);
      this._mode = 'IDLE';
      this.#startTime = performance.now()/1000;
      this.showOverlay(true,'crash');
      this._setBoostAudioState(false);
      this._boost.pause(); this._boost.currentTime = 0;
    }

    startRound(){
      this.#scene.remove(this.#world);
      this.#world = new SandboxWorld(
        ()=> this.onCrash(),
        ()=> { this._score += 1; this._updateHud(); showPointToast("≈ûerit deƒüi≈ütirme", 1); },
        ()=> { this._score += 1; this._updateHud(); showPointToast("Makas", 1); },
        ()=> this._onBoostOvertake()
      );
      this.#scene.add(this.#world);

      const now = performance.now()/1000;
      this._gameStartEpoch = now;
      this._frozenElapsedSec = 0;
      this._score = 0;
      this._hardMode = false;
      this._boostAcc = 0;
      this._spaceDown = false;
      this._mode='RUNNING';
      this._setBoostAudioState(false);
      this._boost.pause(); this._boost.currentTime = 0;

      this._engine.pause(); try { this._engine.currentTime = 0; } catch(_) {}
      if (!this._engMuted) { this._engine.play().catch(()=>{}); this._engStarted = true; }

      this.#world.setTrafficEnabled(true);
      this.#world.clearTraffic();

      this.showOverlay(false);
      showToast("Ba≈üla! üèÅ");
      this._ensureBgmStarted();
      this._ensureEngineStarted();
      this._applyVolumes();
      this._updateAudioUi();
    }

    _ensureBgmStarted(){
      if(this._bgmStarted) return;
      this._bgm.play().then(()=>{ this._bgmStarted = true; }).catch(()=>{});
    }
    _ensureEngineStarted(){
      if (!this._engine) return;
      if (this._engine.paused) { this._engine.play().then(()=>{ this._engStarted = true; }).catch(()=>{}); return; }
      if (!this._engStarted) { this._engine.play().then(()=>{ this._engStarted = true; }).catch(()=>{}); }
    }

    _updateAudioUi(){
      this._bgmMuteBtn?.setAttribute('data-muted', this._bgmMuted ? 'true':'false');
      this._engMuteBtn?.setAttribute('data-muted', this._engMuted ? 'true':'false');
      this._bgm.muted = this._bgmMuted;
      this._engine.muted = this._engMuted;
      this._boostPop.muted = this._engMuted;
    }
    _applyVolumes(){
      const m = (this._bgmVol?.valueAsNumber ?? 60) / 100;
      const e = (this._engVol?.valueAsNumber ?? 70) / 100;
      const boosting = this.#world?.isBoosting?.() ?? false;

      this._bgm.volume = Math.max(0, Math.min(1, m));
      if(boosting){
        this._engine.volume = 0;
        this._boost.volume  = Math.max(0, Math.min(1, e));
      }else{
        this._boost.volume  = 0;
        this._engine.volume = Math.max(0, Math.min(1, e));
      }
    }

    #cacheAnimShaders(){
      this._animShaders = [];
      this.#scene.traverse((o)=>{
        if(o.isMesh && o.material?.userData?.shader){
          this._animShaders.push(o.material.userData.shader);
        }
      });
    }

    #updateEverything(){
      const now=performance.now()/1000;

      // 1 sn uzun basƒ±≈üta "patlat" (tek atƒ±m)
      if (this._spaceDown && this.#world.isBoosting() && this._boostHoldStart > 0 && !this._boostPopPlayed) {
        const held = now - this._boostHoldStart;
        if (held >= 1.0) {
          try { this._boostPop.currentTime = 0; this._boostPop.playbackRate = 0.95 + Math.random()*0.1; this._boostPop.play(); } catch(e) {}
          this._boostPopPlayed = true;
        }
      }

      const t = now - this.#startTime;
      const p = Math.max(0, Math.min(1, t / SUNRISE_DURATION_SEC));
      const dt = now - this._lastNow; this._lastNow = now;

      // Motor pitch'i boost seviyesine g√∂re yumu≈üak deƒüi≈ütir
      if(this._engStarted){
        const b = this.#world.getBoostLevel ? this.#world.getBoostLevel() : (this.#world.isBoosting()?1:0);
        const targetRate = 1.0 + 0.25 * b;
        this._engine.playbackRate += (targetRate - this._engine.playbackRate) * 0.05;
      }
      if(this._engStarted) this._applyVolumes();

      if(this._mode==='RUNNING'){
        const b = this.#world.getBoostLevel ? this.#world.getBoostLevel() : 0;
        if (b > 0.2) {
          this._boostAcc += dt;
          while(this._boostAcc >= 1.0){
            this._boostAcc -= 1.0;
            this._score += 1;
            this._updateHud();
            showPointToast("Boost", 1);
          }
        } else { this._boostAcc = 0; }

        const elapsed = now - this._gameStartEpoch;
        if(!this._hardMode && elapsed >= 60){
          this._hardMode = true; this.#world.enableHardMode(); showToast("Zorluk arttƒ±!");
        }
      }

      // D√ºnya
      this.#world.update();

      // shader uniforms (cache √ºzerinden)
      for(const sh of (this._animShaders || [])){ sh.uniforms.uTime.value = now; }
      if(this.#noisePass){ this.#noisePass.uniforms.uTime.value = now % 10; this.#noisePass.uniforms.uStrength.value = 1.0 - p; }

      // kamera
      const b = this.#world.getBoostLevel ? this.#world.getBoostLevel() : 0;
      const targetFov = 45 + (52 - 45) * b;
      this.#camera.fov += (targetFov - this.#camera.fov) * 0.08;
      const x = (this.#cameraData.positionX * CAMERA_PARALLAX) + 0.15*(Math.sin(0.1*now)+Math.sin(0.05*now));
      const y = this.#cameraData.positionY + 0.3*Math.cos(0.3*now);
      this.#camera.position.set(x,y,1);
      const desiredLookX = this.#world.getCarX() * LOOK_FOLLOW_RATIO;
      this.#cameraData.lookAtX = THREE.MathUtils.lerp(this.#cameraData.lookAtX, desiredLookX, LOOK_FOLLOW_STRENGTH);
      this.#camera.lookAt(this.#cameraData.lookAtX, 0, 200);
      this.#camera.updateProjectionMatrix();

      this.#world.setSunriseProgress(p);
      this.#renderer.toneMappingExposure = 0.6 + 0.9 * p;

      // === Dinamik DPR (mobil) ===
      const instFps = dt > 0 ? (1/dt) : 60;
      this._fpsEMA = this._fpsEMA*0.92 + instFps*0.08;
      if (IS_MOBILE_DEVICE && (now - this._lastFpsAdjust > 2.0)){
        this._lastFpsAdjust = now;
        if (this._fpsEMA < 46 && this._dpr > this._dprMin){
          this._dpr = Math.max(this._dprMin, this._dpr - 0.1);
          this.#renderer.setPixelRatio(this._dpr); this.#onWindowResize();
        } else if (this._fpsEMA > 58 && this._dpr < this._dprMax){
          this._dpr = Math.min(this._dprMax, this._dpr + 0.05);
          this.#renderer.setPixelRatio(this._dpr); this.#onWindowResize();
        }
      }

      this._updateHud();
    }
    #render(){ this.#updateEverything(); this.#composer.render(this.#scene, this.#camera); requestAnimationFrame(this.#render.bind(this)); }
    start(){ this.#render(); }
  }

  function main(){ const root=document.getElementById('root'); const example=new FullScreen3DExample(root); example.start(); }
  document.addEventListener('DOMContentLoaded', main);
  </script>
</body>
</html>
